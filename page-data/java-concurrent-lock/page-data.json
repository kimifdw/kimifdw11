{"componentChunkName":"component---src-templates-blog-post-js","path":"/java-concurrent-lock/","result":{"data":{"site":{"siteMetadata":{"title":"F&Y-BLOG","author":"kimifdw"}},"markdownRemark":{"id":"c5c0f408-a5e7-5782-bb3b-6f9ab98bc79d","html":"<h1 id=\"java-current-lock\"><a href=\"#java-current-lock\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JAVA Current Lock</h1>\n<h2 id=\"locks-全景图\"><a href=\"#locks-%E5%85%A8%E6%99%AF%E5%9B%BE\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LOCKS 全景图</h2>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1e52e2fb4e850386c8bfea35d262475f/15d25/locks.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 497px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 43.91891891891892%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAAA/UlEQVQoz42QbUvDMBSF9///lmWpna7CGK7Ne9I0jbKJY3VpuyRmVaQge4HL/RDOk3PumTknQ6j+5uMTUZnXejn0zFpiLbYd6XvadXQYeAhqKp5NYR+3l/i9RDTlFCA0pwQQAhgFjD1KmbUtvAifeSdgU0CcRmkkIUxQmUQ4ftE0+fGIrsJeQgO4zJRcbHfrGPUc+MRj8lFZX4OdE+gt5SLdbdedJd5X453q91pf3XDemBUTmWCpUs+HQ/nzGGcqu+hcmEUBH2JhQj7pOg9Bj6PugeWrwSUGul7SWDhMdJMb89J+xaqUv+m80kWECZ5znu33m2FgXU9PTvx3/gbdAfWGR96zEwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"image\"\n        title=\"\"\n        src=\"/static/1e52e2fb4e850386c8bfea35d262475f/15d25/locks.png\"\n        srcset=\"/static/1e52e2fb4e850386c8bfea35d262475f/12f09/locks.png 148w,\n/static/1e52e2fb4e850386c8bfea35d262475f/e4a3f/locks.png 295w,\n/static/1e52e2fb4e850386c8bfea35d262475f/15d25/locks.png 497w\"\n        sizes=\"(max-width: 497px) 100vw, 497px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id=\"线程的状态\"><a href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>线程的状态</h2>\n<ul>\n<li>新建状态</li>\n<li>就绪状态</li>\n<li>运行状态</li>\n<li>阻塞状态</li>\n<li>死亡状态</li>\n<li>\n<p>中断状态</p>\n<ol>\n<li>如果一个线程阻塞在<strong>wait方法</strong>，或者线程的<strong>join方法</strong>，再或者<strong>sleep方法</strong>上，线程的中断状态被清空设置为false，并且被interrupt的线程将收到一个中断异常。</li>\n<li>如果线程阻塞在IO操作，<strong>channel将被关闭</strong>，并且线程的中断状态会被设置为true，并且被interrupt的线程将收到一个ClosedByInterruptException异常。</li>\n<li>如果线程阻塞在<strong>selector方法</strong>，中断线程的中断状态将设置为true，并且从select操作立即返回，只有selector的wakeup方法被调用可能返回一个非0值。</li>\n</ol>\n</li>\n</ul>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/77de917212a96ac2e61f50acad887227/0fb99/thread-state.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 69.5945945945946%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsSAAALEgHS3X78AAABbElEQVQoz41Ta2+CMBT1//+yzWUmJHNzW5wgLRTKo7wKQkt3oM6oibr7oclN73ncQ1kopTzPXa1WjuNwnhhjxnE0czVNo7U2t2uBUeCHYcB5GrX41+UyYqFtbV2DLzpc/01glFKSpsk95Tt3nPOyEDAlZSOEKMvyJhhSSZJwHqu5DodDxBiP41ZKSun7ev399dm27bn5hYWBHgszxtzdLkvTvu+R1mazSdMUA6D03B0hPguZvgLDD7irqoIgWmgKkcMEkFEUAQkuM5phZmRh+LPd5nkOvQkMTNPUvr+nhBRFgRZW4yiC54ASsARBQHAlBHihBIq6ruH0uLNWCpRBQAEQ8xDwU2BlBQXi7z/Wbwi/LIt+6B+kbVPpug62u66Fc5hyXXeiJwQ72gUv0r56BrCHLbAwTiSS55mUEoxTBPeVAUD4Ihd2FER7z8uyTGv1+JEorfDZIHgMRethrv++sJfnJyR0/quctgMXzl9JeitgxY4S5gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"image\"\n        title=\"\"\n        src=\"/static/77de917212a96ac2e61f50acad887227/fcda8/thread-state.png\"\n        srcset=\"/static/77de917212a96ac2e61f50acad887227/12f09/thread-state.png 148w,\n/static/77de917212a96ac2e61f50acad887227/e4a3f/thread-state.png 295w,\n/static/77de917212a96ac2e61f50acad887227/fcda8/thread-state.png 590w,\n/static/77de917212a96ac2e61f50acad887227/efc66/thread-state.png 885w,\n/static/77de917212a96ac2e61f50acad887227/0fb99/thread-state.png 965w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h2 id=\"锁的状态\"><a href=\"#%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>锁的状态</h2>\n<blockquote>\n<p>锁可以升级但不能降级 </p>\n</blockquote>\n<ol>\n<li>无锁状态</li>\n<li>偏向锁状态</li>\n<li>轻量级锁状态</li>\n<li>重量级锁状态</li>\n</ol>\n<h2 id=\"锁的种类\"><a href=\"#%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>锁的种类</h2>\n<ol>\n<li>\n<p>自旋锁。\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/903b7483f1736dca6e24ce93a110249f/e9131/self-ring.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 58.78378378378378%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAABFklEQVQoz51R2ZKEIAz0//9wHA9AuUVQdPd1W1JjOdfLVnVxBJLudCrjJjsF47wyTmqD65xWQlwyYQYewfNpyXsV4oL/xk/WB22dsR5XW64+RADFSgQE08F0HI4/yK9QACcfZj/T15jWvG4/iJ9I6wYgeMXBnPIOGdr6lvGeiZ4Pg9RiVAATIxdj12NR4L+WIxzMKOOmMCpDaVg7xpkY+CClMowPYpRoxAWwPCenskHrKe/0CWcKxmIYmfTKjIdrDmn5iA/J5CQ5DLfRHtUKZSoQG2IqBF96RnLb8Vvd3O5N3bT1vRVol4qWul8NW/KGUSnrYRUgtVXGYpgQgilieKB911wMe8ww778vKH1C1/6e9uT2//AHJ9if+glBZfkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"image\"\n        title=\"\"\n        src=\"/static/903b7483f1736dca6e24ce93a110249f/fcda8/self-ring.png\"\n        srcset=\"/static/903b7483f1736dca6e24ce93a110249f/12f09/self-ring.png 148w,\n/static/903b7483f1736dca6e24ce93a110249f/e4a3f/self-ring.png 295w,\n/static/903b7483f1736dca6e24ce93a110249f/fcda8/self-ring.png 590w,\n/static/903b7483f1736dca6e24ce93a110249f/e9131/self-ring.png 614w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<ol>\n<li>优点。实现简单，避免了操作系统进程调度和线程上下文切换的开销。</li>\n<li>\n<p>缺点。</p>\n<ul>\n<li>锁饥饿问题。死锁是两个或者多个进程，<strong>相互等待</strong>对方占有的资源，而又不能释放自己的资源</li>\n<li>性能问题。</li>\n</ul>\n</li>\n<li>适用场景\n锁竞争不激烈、锁持有时间短的场景。</li>\n</ol>\n</li>\n<li>互斥锁。</li>\n<li>CLH锁（自旋锁的改进）。利用严格的FIFO策略避免饥饿问题；利用不同的状态变量中自旋，减少CPU的开销。</li>\n<li>悲观锁策略。每一次执行临界区代码都会产生冲突，获取到锁的时候同时会阻塞其他线程获取该锁。</li>\n<li>\n<p>CAS操作——乐观锁策略</p>\n<ol>\n<li>问题点。</li>\n<li>无法感知检查时中途的变化【ABA问题】</li>\n<li>自旋时间过长【死循环】</li>\n<li>只能保证一个共享变量的原子操作</li>\n</ol>\n</li>\n<li>偏向锁</li>\n</ol>\n<h3 id=\"一-lock（接口）\"><a href=\"#%E4%B8%80-lock%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>一. lock（接口）</h3>\n<ol>\n<li>锁是用于通过多线程控制对共享资源的访问工具，一次只有一个线程可以获取锁，并且对共享资源的所有访问都要求获取锁。</li>\n<li>在锁定时执行的代码由<strong>try-finally</strong>或<strong>try-catch</strong>保护，以确保在必要时释放锁定</li>\n</ol>\n<h4 id=\"11-方法集\"><a href=\"#11-%E6%96%B9%E6%B3%95%E9%9B%86\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1 方法集</h4>\n<ol>\n<li><code class=\"language-text\">lock()</code>。获得锁，如果锁不可用，则当前线程将被<strong>禁用</strong>以进行线程调度，并处于<strong>休眠状态</strong></li>\n<li>\n<p><code class=\"language-text\">lockInterruptibly()</code>。尝试获取可被中断的锁，除非当前线程被 interrupted。</p>\n<ol>\n<li>\n<p>不可用—>可用</p>\n<ul>\n<li>锁是由当前线程获取</li>\n<li>一些其他线程 interrupts 当前线程，并且支持中断锁获取</li>\n</ul>\n</li>\n<li>\n<p>中断清除</p>\n<ul>\n<li>进入该方法时设置了中断状态</li>\n<li>interrupted，同时获取锁，并支持锁中断，然后<code class=\"language-text\">InterruptedException</code>被关上</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><code class=\"language-text\">tryLock()</code>。非阻塞尝试获取锁（可定时的与可轮询的锁获取模式）</li>\n<li>\n<p><code class=\"language-text\">tryLock(long,TimeUnit)</code>。尝试获取超时锁</p>\n<ol>\n<li>\n<p>不可用—>可用</p>\n<ul>\n<li>锁是由当前线程获取</li>\n<li>一些其他线程 interrupts 当前线程，并且支持中断锁获取</li>\n<li>指定的等待时间过去了</li>\n</ul>\n</li>\n<li>\n<p>中断清除</p>\n<ul>\n<li>进入该方法时设置了中断状态</li>\n<li>interrupted，同时获取锁，并支持锁中断，然后<code class=\"language-text\">InterruptedException</code>被关上</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><code class=\"language-text\">unlock</code>。释放锁</li>\n<li><code class=\"language-text\">newCondition()</code>。返回一个新 Condition 绑定到新 Lock 实例</li>\n</ol>\n<h4 id=\"12-内存同步\"><a href=\"#12-%E5%86%85%E5%AD%98%E5%90%8C%E6%AD%A5\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2 内存同步</h4>\n<ol>\n<li>\n<p>所有 Lock 实施必须执行与<strong>内置监视器锁</strong>相同的内存同步语义</p>\n<ul>\n<li>成功的 lock 操作具有与成功锁定动作相同的内存同步效果。</li>\n<li>成功的 unlock 操作具有与成功解锁动作相同的内存同步效果。</li>\n</ul>\n</li>\n<li><strong>不成功的锁定和解锁</strong>操作以及<strong>重入锁定/解锁</strong>操作，不需要任何内存同步效果</li>\n</ol>\n<h4 id=\"13-锁定采集\"><a href=\"#13-%E9%94%81%E5%AE%9A%E9%87%87%E9%9B%86\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3 锁定采集</h4>\n<ul>\n<li>可中断</li>\n<li>不可中断</li>\n<li>定时</li>\n</ul>\n<h3 id=\"二、-readwritelock（接口）\"><a href=\"#%E4%BA%8C%E3%80%81-readwritelock%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>二、 ReadWriteLock（接口）</h3>\n<ol>\n<li>支持<strong>并发访问</strong>共享资源</li>\n<li>一个线程成功读锁定将会看到之前发布的写锁定所做的所有更新</li>\n<li>\n<p>适用场景</p>\n<ol>\n<li>读多写少的场景\n<code class=\"language-text\">Determining whether to grant the read lock or the write lock, when both readers and writers are waiting, at the time that a writer releases the write lock. Writer preference is common, as writes are expected to be short and infrequent. Reader preference is less common as it can lead to lengthy delays for a write if the readers are frequent and long-lived as expected. Fair, or &quot;in-order&quot; implementations are also possible.</code></li>\n<li>是否存在读锁被激活而写锁在等待，可能会降低并发的可能性\n<code class=\"language-text\">Determining whether readers that request the read lock while a reader is active and a writer is waiting, are granted the read lock. Preference to the reader can delay the writer indefinitely, while preference to the writer can reduce the potential for concurrency.</code></li>\n<li>锁是否可重入\n<code class=\"language-text\">Determining whether the locks are reentrant: can a thread with the write lock reacquire it? Can it acquire a read lock while holding the write lock? Is the read lock itself reentrant?</code></li>\n<li>是否允许锁降级\n<code class=\"language-text\">Can the write lock be downgraded to a read lock without allowing an intervening writer? Can a read lock be upgraded to a write lock, in preference to other waiting readers or writers?</code></li>\n</ol>\n</li>\n<li>\n<p>方法</p>\n<ol>\n<li><code class=\"language-text\">readLock()</code>。读锁</li>\n<li><code class=\"language-text\">writeLock()</code>。写锁</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"三、-condition（接口）\"><a href=\"#%E4%B8%89%E3%80%81-condition%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>三、 Condition（接口）</h3>\n<h3 id=\"四、-reentrantlockreentrantreadwritelock\"><a href=\"#%E5%9B%9B%E3%80%81-reentrantlockreentrantreadwritelock\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>四、 ReentrantLock/ReentrantReadWriteLock</h3>\n<ol>\n<li>重进入。任意线程在获取到锁之后能购再次获取该锁而不会被锁所阻塞 </li>\n<li>与synchronized类似，具有更好的扩展性</li>\n<li>定义。由最后成功锁定但尚未解锁的线程所拥有，可以用<code class=\"language-text\">isHeldByCurrentThread</code>和<code class=\"language-text\">getHoldCount</code>来进行检查</li>\n<li>在公平锁场景下，不能保证任何特定的执行顺序，更倾向授予<strong>等待时间最长</strong>的线程的访问</li>\n<li>未定义时长的<code class=\"language-text\">tryLock</code>支持不公平锁，同一线程下的锁有限制，超过此限制会导致锁定方法异常</li>\n<li>利用<strong>AQS</strong>实现同步（包含公平和非公平），默认ReentrantLock为不公平锁，独占锁</li>\n<li>\n<p>方法（除LOCK接口外）</p>\n<ol>\n<li>\n<p>测试和调试。</p>\n<ul>\n<li><code class=\"language-text\">getHoldCount</code>。查询当前线程对该锁的保持数目，此信息只用于测试和调试。0表示没有获取到锁</li>\n<li><code class=\"language-text\">isHeldByCurrentThread</code>。查询当前锁是否由当前线程所持有</li>\n</ul>\n</li>\n<li>\n<p>系统监控。</p>\n<ul>\n<li><code class=\"language-text\">isLocked</code>。查询此锁是否有任何线程保持</li>\n<li><code class=\"language-text\">getOwner</code>。返回当前拥有此锁的线程，也有可能为空</li>\n<li><code class=\"language-text\">hasQueuedThreads</code>/<code class=\"language-text\">hasQueuedThread</code>/<code class=\"language-text\">getQueueLength</code>/<code class=\"language-text\">getQueuedThreads</code>。查询等待锁的线程队列信息</li>\n<li><code class=\"language-text\">hasWaiters</code>/<code class=\"language-text\">getWaitQueueLength</code>/<code class=\"language-text\">getWaitingThreads</code>。根据条件查询等待线程的信息</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>ReentrantReadWriteLock与ReentrantLock的方法类似</li>\n<li>RRW当线程获取到写锁后，可以降级为读锁</li>\n</ol>\n<h3 id=\"五、-stampedlock（18）\"><a href=\"#%E4%BA%94%E3%80%81-stampedlock%EF%BC%8818%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>五、 StampedLock（1.8）</h3>\n<ol>\n<li>功能锁，基于三种模式(读、写、乐观读)来控制读/写访问，锁状态基于版本和模式控制，如版本返回0则表示无法获取访问权限，锁的释放和转换需要基于返回版本来控制，不匹配则失败。</li>\n<li>\n<p>三种模式</p>\n<ul>\n<li>writting==>1。独占锁类似</li>\n<li>reading==>2。读锁类似</li>\n<li>Optimistic reading==>3（乐观读模式），乐观读锁在数据一致性上需要复制一个对象</li>\n</ul>\n</li>\n<li>设计为在线程安全组件的开发中用作内部实用程序，采用序列锁的算法，而并非其他锁普遍采用的AQS。利用CLH队列进行线程的管理，通过同步状态值来表示锁的状态和类型。</li>\n<li>\n<p>方法</p>\n<ol>\n<li><code class=\"language-text\">tryConvertToReadLock</code>/<code class=\"language-text\">tryConvertToOptimisticRead</code>/<code class=\"language-text\">tryConvertToWriteLock</code>。锁切换</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"六、abstractqueuedsynchronizer\"><a href=\"#%E5%85%AD%E3%80%81abstractqueuedsynchronizer\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>六、AbstractQueuedSynchronizer</h3>\n<ol>\n<li>在JDK1.6后增加了独占锁功能，由<code class=\"language-text\">AbstractOwnableSynchronizer</code>实现</li>\n<li>一个框架，用于实现依赖于FIFO等待队列的阻塞锁和相关的同步器（semaphores、events等），为依赖单个原子int值表示状态的同步器提供有用的基础</li>\n<li>状态字段的同步操作依赖<code class=\"language-text\">getState</code>、<code class=\"language-text\">setState</code>和<code class=\"language-text\">compareAndSetState</code>的原子操作来更新int值（基于unsafe类库实现）</li>\n<li>子类应定义为非公共内部帮助类来实现其封闭类的同步属性方法</li>\n<li>默认支持互斥模式或共享模式，等待线程共享FIFO队列</li>\n<li>ConditionObject类由支持独占模式的子类用作Condition实现</li>\n<li>\n<p>用法（使用<code class=\"language-text\">getState</code>、<code class=\"language-text\">setState</code>、<code class=\"language-text\">compareAndSetState</code>检查和修改同步状态），只支持实现以下方法【线程安全】</p>\n<ol>\n<li>tryAcquire。排他获取锁</li>\n<li>tryRelease。排他释放锁</li>\n<li>tryAcquireShared。共享获取锁</li>\n<li>tryReleaseShared。共享释放锁</li>\n<li>isHeldExclusively。是否为排他状态</li>\n</ol>\n</li>\n<li>\n<p><em>核心</em></p>\n<ol>\n<li>\n<p>CLH队列【JSR-166】，FIFO的等待队列。\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/09365aa4ff551b77347ee536ccfd91a6/37e0d/CLH.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 482px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 14.18918918918919%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsSAAALEgHS3X78AAAAV0lEQVQI101OiwoAIQjr/z83svJVt7LiBoob2zDNOccYqioib5dSiAiH2dJgcHe98A0EE8bNcs5UKRzMjIrYUDr3WypmhgO9tbUTDrxuON47f7q/ODTwARhvsM/sOPm6AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"image\"\n        title=\"\"\n        src=\"/static/09365aa4ff551b77347ee536ccfd91a6/37e0d/CLH.png\"\n        srcset=\"/static/09365aa4ff551b77347ee536ccfd91a6/12f09/CLH.png 148w,\n/static/09365aa4ff551b77347ee536ccfd91a6/e4a3f/CLH.png 295w,\n/static/09365aa4ff551b77347ee536ccfd91a6/37e0d/CLH.png 482w\"\n        sizes=\"(max-width: 482px) 100vw, 482px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<ol>\n<li>一个<strong>FIFO的隐式双向队列</strong>，队列中每个节点等待前驱节点释放共享状态（锁）被唤醒就可以了</li>\n<li>从tail入队【原子操作】，head出队【原子操作】</li>\n<li><code class=\"language-text\">prev</code>链用于处理取消</li>\n<li><code class=\"language-text\">next</code>链来实现阻止机制，每个节点的线程ID保留在主机的节点上，则前任通过遍历下一个链接来确定自己是哪个线程。</li>\n<li>在构造节点时，设置头和尾指针。</li>\n<li>\n<p>问题点。</p>\n<ol>\n<li>如何排队？使用反向链表的形式进行排队，后继节点主动询问，而不是前继节点主动通知，从尾部进行插入</li>\n<li>排队是否公平？公平锁，后申请获取锁的排在队列末尾</li>\n<li>如何唤醒？CLH通过每个线程<strong>自旋</strong>。每个等待线程通过不断自旋前继节点状态判断是否能获取到锁。</li>\n</ol>\n</li>\n<li>锁的释放和锁定\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e2cae6263d0ad94e48d4a152c2dd7981/17d73/clh-operate.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 571px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 72.2972972972973%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsSAAALEgHS3X78AAADVklEQVQoz2Po7OxkYGDg5uLg4mATExXm4GBjZ2cXFRXhZGfjYGPlAJIgwA5ksLOxiomKcHFy8vLyALXExcUx9HT3Alls7Nxs7Ly8AqJMTKyMDEwiwmKsrJxMTOzMTGxALhMjCwszGwszOx+fMCMjKxsrO1BLYmISUPNEBgZmdtsytrBFXFHLBAyDBNlYhXX82AJncwbP4XYsExEU4mbhYTFKZQuazRs+T9giUk5CmIGBPSkhg6G3ZwYDgwCHTSN3+Bq+iNW6fsUGqpqC2pEcEesFotdJB02wtXEQ5JZnNSvnilwvELVWN6zKwdaCgUE4ObGQob9/Lguzsqi0nZC0o7Csq6SsjaS4kaySg5C8K6+0s4ico4y8ubSkuYSsg6CMM5+ks4ScvbKiFQujUkZaFcPUqYtFxUy1NJ01NRzNTHzU1JzU1V10dNzUVBzUVR3UVB1UVB01NFzU1Z2AXGNDL3U1J20tN2EBg8K8Zoa5c1fLy9tpa3loa3vpG/ipqblpanno63trqTtrgpCLpqa7urobkAEUMTH01VR309f3U5C1q6roYVi8eKOunreUf59g5GKxhNUiBgFaSlpG7oX8wbNFwheIejbKyqhamfoqe9YLhMyViF4qap2hpqSpp+Pb3DiVYdXK7bY2EUL+01nD13JHb1RxTfewczT2rWEI3cgVv10oZIatrb2ve5SsXx9D+EbuhO3SPnUu9o7WVuE9XXMZ1m/Y7eGV5B5Y5Ohf6hJS6RmQFRaS4R+ab+tbYudb6uxXEByUFhme6xlUYuVbZu1b4eKfFx6e4emROHnSIobNm/eFhOalJ1elJ5Vnp1WkJpWnJFclJ1fGpNRGJ9dGJVaHhmYmJpRkpFakJ5alJZamJAIVVIcGZc+asZJhx45DMbGlWZmNmen1eblNuTlNBVl1kentHHEbRNK2icUtkdfQjwhNKSxsy8yoy0ivByrLzmyIiy5duGAdw86dR+ISykHashsLC1ry85uL8hpj0ls4fWaKBM+VDJxs5eSXGJ9fXNyek12fk9WQk90AVJyYUL540XqGhw+f7tx15MCBUwcPnDxy+NThw6eOHj598NCpHftOb91zatuek3v3HT58GCh1GqjgwP4T+/efPHjg1O5dR65fvwsAVt8GB364rE4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"image\"\n        title=\"\"\n        src=\"/static/e2cae6263d0ad94e48d4a152c2dd7981/17d73/clh-operate.png\"\n        srcset=\"/static/e2cae6263d0ad94e48d4a152c2dd7981/12f09/clh-operate.png 148w,\n/static/e2cae6263d0ad94e48d4a152c2dd7981/e4a3f/clh-operate.png 295w,\n/static/e2cae6263d0ad94e48d4a152c2dd7981/17d73/clh-operate.png 571w\"\n        sizes=\"(max-width: 571px) 100vw, 571px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>锁的实现（尾部插入实现）\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/33708c0565bf6dfcaded2d17ac10c637/cd039/CLH-java.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 555px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 54.05405405405405%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABqklEQVQoz3XP35KaMBQGcN6jf7a4ipCcBARCSEggIiuoa7ttL9qb3lTEJ3QGu6/gQxWmnV50dOZ3cc6cfPNNLAPJ3tdGV0muicpCKSIhYylVJuKUB4UOlOJCFrnWmWKmGE46SqM4fH39ZT3b9JvLv0zDKpK82YW7PaubNC+rPC8zkUQ6UWm28U2z0LWvlS6YLA1NeNL3vVXM8M6Tn13+fc5+OPEmrUyoc5mpXKcELTyPYATUw2REEfIxxr4HAP3lYi1dpF0wc7RcTKsIZ67DXTelWA6wSwAwBkB/DfOfFSM8NkcOqNXmU73frosS4rUuhfEZDzDyEHIB4XvG8HQ+l/Wu2m6brGyIGMJMI2bmQsc602TsuR8mHjLB8JJLnhilhBTEH4+U0IAGBBNAt/X9xZJOsHKYJjKswuVTmkAUQ8R4smCEAMUe/vfh/4zNC3f2VRYfn+rnbf3CxAuN1pytZJynIAOfAlAgN12G5vDhTT6Z1WFYJE7xaBt4kLEdTWz6/q1vv3u07cmH287ns/Xz0B677tC27aFru65tu+Oh67rT6Hg6Hbt7rtfrb84qno09DviMAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"image\"\n        title=\"\"\n        src=\"/static/33708c0565bf6dfcaded2d17ac10c637/cd039/CLH-java.png\"\n        srcset=\"/static/33708c0565bf6dfcaded2d17ac10c637/12f09/CLH-java.png 148w,\n/static/33708c0565bf6dfcaded2d17ac10c637/e4a3f/CLH-java.png 295w,\n/static/33708c0565bf6dfcaded2d17ac10c637/cd039/CLH-java.png 555w\"\n        sizes=\"(max-width: 555px) 100vw, 555px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>\n<p>AQS的优化点【基于CLH队列】</p>\n<ol>\n<li>将自旋锁改为基于<strong>LockSupport</strong>的线程阻塞操作</li>\n<li>\n<p>拓展CLH队列</p>\n<ol>\n<li>\n<p>扩展每个节点的状态，<code class=\"language-text\">volatile int waitStatus</code>。</p>\n<ul>\n<li>CANCELLED[1]。后驱节点被中断或超时，需要移出队列。在同步队列中等待超时或被中断，需要从队列中取消等待，在该状态将不会变化</li>\n<li>SIGNAL[-1]。后驱节点被阻塞了，正常等待。后继节点地线程处于等待状态，当前节点释放获取取消同步状态，后继节点地线程即开始运行</li>\n<li>CONDITION[-2]。Condition专用</li>\n<li>PROPAGATE[-3]。传播，适用于共享模式，下一次共享式同步状态获取将会无条件地被传播下去</li>\n<li>IINITAL[0]。初始值</li>\n</ul>\n</li>\n<li>显式的维护前驱节点和后继节点。锁的释放会去主动唤醒下一个线程</li>\n<li>辅助GC。释放锁时显示设置为null</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>同步状态的定义</p>\n<ol>\n<li><code class=\"language-text\">getState</code>。同步返回当前的值</li>\n<li><code class=\"language-text\">setState</code>。同步修改当前值</li>\n<li><code class=\"language-text\">compareAndSetHead</code>/<code class=\"language-text\">compareAndSetState</code>/<code class=\"language-text\">compareAndSetTail</code>/<code class=\"language-text\">compareAndSetWaitStatus</code>/<code class=\"language-text\">compareAndSetNext</code>。使用unsafe类来实现原子操作</li>\n</ol>\n</li>\n<li>线程的阻塞/唤醒【利用<strong>LockSupport</strong>的park和unpark来实现】</li>\n<li>一次lock的调用过程</li>\n<li>调用<strong>tryAcquire方法</strong>尝试获取锁，获取成功的话修改state并直接返回true，获取失败的话把当前线程加到等待队列<strong>addWaiter</strong>中</li>\n<li>加到等待队列之后先检查前置节点状态是否是signal，如果是的话直接阻塞当前线程等待唤醒，如果不是的话判断是否是cancel状态，是cancel状态就往前遍历并把cancel状态的节点从队列中删除。如果状态是0或者propagate的话将其修改成signal</li>\n<li>阻塞被唤醒之后如果是队首并且尝试获取锁成功就返回true，否则就继续执行前一步的代码进入阻塞</li>\n<li>一次unlock的调用过程</li>\n<li>修改状态位</li>\n<li>唤醒排队的节点</li>\n<li>结合lock方法，被唤醒的节点会自动替换当前节点成为head</li>\n</ol>\n</li>\n<li>\n<p>源码分析</p>\n<ol>\n<li>\n<p>lock核心</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token function\">acquireQueued</span><span class=\"token punctuation\">(</span><span class=\"token function\">addWaiter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Node</span><span class=\"token punctuation\">.</span>EXCLUSIVE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">selfInterrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>unlock核心</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">tryRelease</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Node</span> h <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> h<span class=\"token punctuation\">.</span>waitStatus <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">unparkSuccessor</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>enq（尾部入队）</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token class-name\">Node</span> <span class=\"token function\">addWaiter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Node</span> mode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token class-name\">Node</span> node <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> mode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Try the fast path of enq; backup to full enq on failure</span>\n<span class=\"token class-name\">Node</span> pred <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// cas入尾队列，如不行则在调用enq入队</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pred <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    node<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> pred<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndSetTail</span><span class=\"token punctuation\">(</span>pred<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        pred<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">enq</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>其他实现</li>\n<li>\n<p><code class=\"language-text\">CountDownLatch</code>。计数使用，一旦降为0，无法重置。</p>\n<ol>\n<li>\n<p>场景。</p>\n<ul>\n<li>作为一个开关或入口【初始值设为1】</li>\n<li>作为一个完成信号。</li>\n<li>将问题分成N个部分，当所有子任务完成后才能通过等待</li>\n</ul>\n</li>\n<li>内存一致性影响。在计数达到零之前，一个线程调用<code class=\"language-text\">countDown</code>方法之前，一定有一个线程成功调用了<code class=\"language-text\">await</code>方法</li>\n<li>\n<p>方法</p>\n<ul>\n<li><code class=\"language-text\">await()</code>。等当前线程等待，直到锁存器递减计数到0为止</li>\n<li><code class=\"language-text\">countDown()</code>。减少锁存器的计数，如果计数达到0，则释放所有等待线程</li>\n<li>\n<p>由AQS来进行计数，采用共享锁模式。一旦被唤醒，会向队列后部传播（<strong>Propagate</strong>）状态，以实现共享结点的连续唤醒</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Sync</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractQueuedSynchronizer</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> serialVersionUID <span class=\"token operator\">=</span> <span class=\"token number\">4982264981922014374L</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Sync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> count<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">getCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">return</span> <span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">int</span> <span class=\"token function\">tryAcquireShared</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> acquires<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">1</span> <span class=\"token operator\">:</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryReleaseShared</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> releases<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token comment\">// Decrement count; signal when transition to zero</span>\n     <span class=\"token comment\">// 执行自旋锁并CAS</span>\n     <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n           <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> nextc <span class=\"token operator\">=</span> c<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndSetState</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> nextc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n           <span class=\"token keyword\">return</span> nextc <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n</li>\n<li>\n<p>资料</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000015807573\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">CountDownLatch源码分析</a></li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p><code class=\"language-text\">CyclicBarrier</code>。与<code class=\"language-text\">CountDownLatch</code>类似，区别是支持数值重置，允许一组线程全部相互等待以到达一个公共的屏障点。</p>\n<ol>\n<li>\n<p>场景。</p>\n<ul>\n<li>涉及固定大小的线程方的程序中使用。</li>\n<li>若其中一个线程出现异常，则所有线程都会以<code class=\"language-text\">BrokenBarrierException</code>异常退出【all-or-none breakage model】</li>\n</ul>\n</li>\n<li>内存一致性影响。一个线程调用<code class=\"language-text\">await</code>方法之前，一定有一个线程成功调用了<code class=\"language-text\">await</code>方法</li>\n<li>\n<p>方法【一个栅栏对应一个generation对象，对象包含一个broken值来标识】</p>\n<ul>\n<li><code class=\"language-text\">await</code>。直到所有各方都在此栅栏上调用了await，核心逻辑在<code class=\"language-text\">doawait</code>方法里</li>\n<li><code class=\"language-text\">reset</code>。先break，在重新创建新的generation对象</li>\n<li>使用<code class=\"language-text\">ReentrantLock</code>和<code class=\"language-text\">Condition</code>来实现</li>\n</ul>\n</li>\n<li>\n<p>资料</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000015888316?utm_source=sf-related\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">CyclicBarrier源码分析</a></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><code class=\"language-text\">semaphore</code>。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"七、abstractownablesynchronizer（16）\"><a href=\"#%E4%B8%83%E3%80%81abstractownablesynchronizer%EF%BC%8816%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>七、AbstractOwnableSynchronizer（1.6）</h3>\n<blockquote>\n<p>基础类，为AQS提供了独占锁等概念。包含定义拥有独占访问权限的锁</p>\n</blockquote>\n<h3 id=\"八、locksupport\"><a href=\"#%E5%85%AB%E3%80%81locksupport\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>八、LockSupport</h3>\n<ol>\n<li>创建锁和其他同步类的基本线程阻塞原语</li>\n<li>重点关注<code class=\"language-text\">park</code>方法和<code class=\"language-text\">unpark</code>方法，不能累加许可（与Semaphore不同）</li>\n<li>\n<p>方法（都依赖unsafe包中对应的方法来进行控制）</p>\n<ol>\n<li><code class=\"language-text\">park</code>。禁止当前线程被调度除非得到许可，使用unsafe.pack包来实现，响应中断但不抛出异常。一般要放在一个<strong>循环判断体</strong>里面</li>\n<li><code class=\"language-text\">unpark</code>。为给定的线程提供许可</li>\n<li><code class=\"language-text\">getBroker</code>。返回提供给最近调用尚未解除阻塞的park方法的阻止程序对象，如果不阻止则返回null。 返回的值只是一个瞬间的快照 - 线程可能已经被阻止或阻止在不同的阻止对象上。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"synchronized（锁定的方法块）\"><a href=\"#synchronized%EF%BC%88%E9%94%81%E5%AE%9A%E7%9A%84%E6%96%B9%E6%B3%95%E5%9D%97%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>synchronized（锁定的方法块）</h2>\n<ol>\n<li>提供对与每个对象相关联的隐式监视器锁的访问，但强制所有锁获取和释放以块结构的方式发生</li>\n<li>当获取多个锁时，它们必须以<strong>相反的顺序</strong>被释放，并且所有的锁都必须被释放在与它们相同的词汇范围内。</li>\n<li>策略。一个对象对一个以上的线程可见，则对该对象变量的所有读取或写入均通过同步方法完成。</li>\n<li>每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。</li>\n<li>利用java的指令集实现的锁，通过monitorenter和monitorexit jvm指令【监视器锁】来完成的，而监视器锁底层依赖于操作系统的Mutex Lock（互斥锁）来实现</li>\n</ol>\n<h2 id=\"资料整理\"><a href=\"#%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>资料整理</h2>\n<ol>\n<li><a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">jdk8 内存模型</a></li>\n<li><a href=\"https://www.matools.com/api/java8\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">java se8 中文版</a></li>\n<li><a href=\"https://juejin.cn/post/6844904047305031693\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">史上最全的 Java 并发系列</a></li>\n<li><del><a href=\"https://segmentfault.com/a/1190000018948010\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JUC 同步队列</a></del></li>\n<li><a href=\"https://segmentfault.com/blog/ressmix_multithread?page=1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JUC 同步队列</a></li>\n<li><a href=\"https://blog.csdn.net/qq_34337272/article/details/81252853\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">面试</a></li>\n<li><del><a href=\"https://www.infoq.cn/article/BVPvyVxjKM8ZSTSpTi0L?utm_source=rss&#x26;utm_medium=article\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">CLH队列</a></del></li>\n<li><a href=\"http://ifeve.com/java_lock_see2/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Java锁的种类以及辨析</a></li>\n<li><a href=\"http://ifeve.com/juc-aqs-reentrantlock/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ReentrantLock源码分析</a></li>\n<li><del><a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.State.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">线程状态</a></del></li>\n<li><a href=\"http://ifeve.com/java%e4%ba%92%e6%96%a5%e9%94%81synchronizedlock%ef%bc%9a%e8%a1%8c%e4%b8%ba%e5%88%86%e6%9e%90%e5%8f%8a%e6%ba%90%e7%a0%81/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JAVA互斥锁(synchronized&#x26;Lock)：行为分析及源码</a></li>\n<li><a href=\"https://www.cnblogs.com/wangwudi/p/12302668.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">synchronized简介</a></li>\n<li><a href=\"https://blog.csdn.net/Seky_fei/article/details/106111832?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&#x26;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">深入图解AQS实现原理和源码分析</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/29866981\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">synchronized总结</a></li>\n</ol>","timeToRead":17,"frontmatter":{"title":"java concurrent locks","date":"March 16, 2021","spoiler":"locks"},"fields":{"slug":"/java-concurrent-lock/"}}},"pageContext":{"slug":"/java-concurrent-lock/","previous":{"fields":{"slug":"/data-governance/","directoryName":"data-governance"},"frontmatter":{"title":"数据治理"}},"next":{"fields":{"slug":"/epoll/","directoryName":"epoll"},"frontmatter":{"title":"epoll 介绍"}}}},"staticQueryHashes":["336482444"]}