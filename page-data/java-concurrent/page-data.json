{"componentChunkName":"component---src-templates-blog-post-js","path":"/java-concurrent/","result":{"data":{"site":{"siteMetadata":{"title":"F&Y-BLOG","author":"kimifdw"}},"markdownRemark":{"id":"cd8c0bca-411b-527d-9aa1-87f3c1da843c","html":"<h1 id=\"java-current-lock\"><a href=\"#java-current-lock\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JAVA Current Lock</h1>\n<h2 id=\"locks-全景图\"><a href=\"#locks-%E5%85%A8%E6%99%AF%E5%9B%BE\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LOCKS 全景图</h2>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1e52e2fb4e850386c8bfea35d262475f/15d25/locks.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 497px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 43.91891891891892%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAAA/UlEQVQoz42QbUvDMBSF9///lmWpna7CGK7Ne9I0jbKJY3VpuyRmVaQge4HL/RDOk3PumTknQ6j+5uMTUZnXejn0zFpiLbYd6XvadXQYeAhqKp5NYR+3l/i9RDTlFCA0pwQQAhgFjD1KmbUtvAifeSdgU0CcRmkkIUxQmUQ4ftE0+fGIrsJeQgO4zJRcbHfrGPUc+MRj8lFZX4OdE+gt5SLdbdedJd5X453q91pf3XDemBUTmWCpUs+HQ/nzGGcqu+hcmEUBH2JhQj7pOg9Bj6PugeWrwSUGul7SWDhMdJMb89J+xaqUv+m80kWECZ5znu33m2FgXU9PTvx3/gbdAfWGR96zEwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"image\"\n        title=\"\"\n        src=\"/static/1e52e2fb4e850386c8bfea35d262475f/15d25/locks.png\"\n        srcset=\"/static/1e52e2fb4e850386c8bfea35d262475f/12f09/locks.png 148w,\n/static/1e52e2fb4e850386c8bfea35d262475f/e4a3f/locks.png 295w,\n/static/1e52e2fb4e850386c8bfea35d262475f/15d25/locks.png 497w\"\n        sizes=\"(max-width: 497px) 100vw, 497px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h3 id=\"一-lock（接口）\"><a href=\"#%E4%B8%80-lock%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>一. lock（接口）</h3>\n<ol>\n<li>锁是用于通过多线程控制对共享资源的访问工具，一次只有一个线程可以获取锁，并且对共享资源的所有访问都要求获取锁。</li>\n<li>在锁定时执行的代码由<strong>try-finally</strong>或<strong>try-catch</strong>保护，以确保在必要时释放锁定</li>\n</ol>\n<h4 id=\"11-方法集\"><a href=\"#11-%E6%96%B9%E6%B3%95%E9%9B%86\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1 方法集</h4>\n<ol>\n<li><code class=\"language-text\">lock()</code>。获得锁，如果锁不可用，则当前线程将被<strong>禁用</strong>以进行线程调度，并处于<strong>休眠状态</strong></li>\n<li>\n<p><code class=\"language-text\">lockInterruptibly</code>。尝试获取可被中断的锁，除非当前线程被 interrupted。</p>\n<ol>\n<li>不可用—>可用</li>\n<li>锁是由当前线程获取</li>\n<li>一些其他线程 interrupts 当前线程，并且支持中断锁获取</li>\n<li>中断清除</li>\n<li>进入该方法时设置了中断状态</li>\n<li>interrupted，同时获取锁，并支持锁中断，然后<code class=\"language-text\">InterruptedException</code>被关上</li>\n</ol>\n</li>\n<li><code class=\"language-text\">tryLock()</code>。非阻塞尝试获取锁（可定时的与可轮询的锁获取模式）</li>\n<li>\n<p><code class=\"language-text\">tryLock(long,TimeUnit)</code>。尝试获取超时锁</p>\n<ol>\n<li>不可用—>可用</li>\n<li>锁是由当前线程获取</li>\n<li>一些其他线程 interrupts 当前线程，并且支持中断锁获取</li>\n<li>指定的等待时间过去了</li>\n<li>中断清除</li>\n<li>进入该方法时设置了中断状态</li>\n<li>interrupted，同时获取锁，并支持锁中断，然后<code class=\"language-text\">InterruptedException</code>被关上</li>\n</ol>\n</li>\n<li><code class=\"language-text\">unlock</code>。释放锁</li>\n<li><code class=\"language-text\">newCondition()</code>。返回一个新 Condition 绑定到新 Lock 实例</li>\n</ol>\n<h4 id=\"12-内存同步\"><a href=\"#12-%E5%86%85%E5%AD%98%E5%90%8C%E6%AD%A5\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2 内存同步</h4>\n<ol>\n<li>\n<p>所有 Lock 实施必须执行与<strong>内置监视器锁</strong>相同的内存同步语义</p>\n<ol>\n<li>成功的 lock 操作具有与成功锁定动作相同的内存同步效果。</li>\n<li>成功的 unlock 操作具有与成功解锁动作相同的内存同步效果。</li>\n</ol>\n</li>\n<li><strong>不成功的锁定和解锁</strong>操作以及<strong>重入锁定/解锁</strong>操作，不需要任何内存同步效果</li>\n</ol>\n<h4 id=\"13-锁定采集\"><a href=\"#13-%E9%94%81%E5%AE%9A%E9%87%87%E9%9B%86\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3 锁定采集</h4>\n<ol>\n<li>可中断</li>\n<li>不可中断</li>\n<li>定时</li>\n</ol>\n<h3 id=\"二、-readwritelock（接口）\"><a href=\"#%E4%BA%8C%E3%80%81-readwritelock%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>二、 ReadWriteLock（接口）</h3>\n<ol>\n<li>支持<strong>并发访问</strong>共享资源</li>\n<li>一个线程成功读锁定将会看到之前发布的写锁定所做的所有更新</li>\n<li>\n<p>适用场景</p>\n<ol>\n<li>读多写少的场景\n<code class=\"language-text\">Determining whether to grant the read lock or the write lock, when both readers and writers are waiting, at the time that a writer releases the write lock. Writer preference is common, as writes are expected to be short and infrequent. Reader preference is less common as it can lead to lengthy delays for a write if the readers are frequent and long-lived as expected. Fair, or &quot;in-order&quot; implementations are also possible.</code></li>\n<li>是否存在读锁被激活而写锁在等待，可能会降低并发的可能性\n<code class=\"language-text\">Determining whether readers that request the read lock while a reader is active and a writer is waiting, are granted the read lock. Preference to the reader can delay the writer indefinitely, while preference to the writer can reduce the potential for concurrency.</code></li>\n<li>锁是否可重入\n<code class=\"language-text\">Determining whether the locks are reentrant: can a thread with the write lock reacquire it? Can it acquire a read lock while holding the write lock? Is the read lock itself reentrant?</code></li>\n<li>是否允许锁降级\n<code class=\"language-text\">Can the write lock be downgraded to a read lock without allowing an intervening writer? Can a read lock be upgraded to a write lock, in preference to other waiting readers or writers?</code></li>\n</ol>\n</li>\n<li>\n<p>方法</p>\n<ol>\n<li><code class=\"language-text\">readLock()</code>。读锁</li>\n<li><code class=\"language-text\">writeLock()</code>。写锁</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"三、-condition（接口）\"><a href=\"#%E4%B8%89%E3%80%81-condition%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>三、 Condition（接口）</h3>\n<h3 id=\"四、-reentrantlockreentrantreadwritelock\"><a href=\"#%E5%9B%9B%E3%80%81-reentrantlockreentrantreadwritelock\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>四、 ReentrantLock/ReentrantReadWriteLock</h3>\n<ol>\n<li>重进入。任意线程在获取到锁之后能购再次获取该锁而不会被锁所阻塞 </li>\n<li>与synchronized类似，具有更好的扩展性</li>\n<li>定义。由最后成功锁定但尚未解锁的线程所拥有，可以用<code class=\"language-text\">isHeldByCurrentThread</code>和<code class=\"language-text\">getHoldCount</code>来进行检查</li>\n<li>在公平锁场景下，不能保证任何特定的执行顺序，更倾向授予<strong>等待时间最长</strong>的线程的访问</li>\n<li>未定义时长的<code class=\"language-text\">tryLock</code>支持不公平锁，同一线程下的锁有限制，超过此限制会导致锁定方法异常</li>\n<li>利用<strong>AQS</strong>实现同步（包含公平和非公平），默认ReentrantLock为不公平锁，独占锁</li>\n<li>\n<p>方法（除LOCK接口外）</p>\n<ol>\n<li>\n<p>测试和调试。</p>\n<ol>\n<li><code class=\"language-text\">getHoldCount</code>。查询当前线程对该锁的保持数目，此信息只用于测试和调试。0表示没有获取到锁</li>\n<li><code class=\"language-text\">isHeldByCurrentThread</code>。查询当前锁是否由当前线程所持有</li>\n</ol>\n</li>\n<li>\n<p>系统监控。</p>\n<ol>\n<li><code class=\"language-text\">isLocked</code>。查询此锁是否有任何线程保持</li>\n<li><code class=\"language-text\">getOwner</code>。返回当前拥有此锁的线程，也有可能为空</li>\n<li><code class=\"language-text\">hasQueuedThreads</code>/<code class=\"language-text\">hasQueuedThread</code>/<code class=\"language-text\">getQueueLength</code>/<code class=\"language-text\">getQueuedThreads</code>。查询等待锁的线程队列信息</li>\n<li><code class=\"language-text\">hasWaiters</code>/<code class=\"language-text\">getWaitQueueLength</code>/<code class=\"language-text\">getWaitingThreads</code>。根据条件查询等待线程的信息</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>ReentrantReadWriteLock与ReentrantLock的方法类似</li>\n<li>\n<p>RRW当线程获取到写锁后，可以降级为读锁</p>\n<h3 id=\"五、-stampedlock（18）\"><a href=\"#%E4%BA%94%E3%80%81-stampedlock%EF%BC%8818%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>五、 StampedLock（1.8）</h3>\n</li>\n<li>功能锁，基于三种模式来控制读/写访问，锁状态基于版本和模式控制，如版本返回0则表示无法获取访问权限，锁的释放和转换需要基于返回版本来控制，不匹配则失败。</li>\n<li>\n<p>三种模式</p>\n<ol>\n<li>writting==>1。独占锁类似</li>\n<li>reading==>2。读锁类似</li>\n<li>Optimistic reading==>3（乐观读模式），乐观读锁在数据一致性上需要复制一个对象</li>\n</ol>\n</li>\n<li>设计为在线程安全组件的开发中用作内部实用程序，采用序列锁的算法，而并非其他锁普遍采用的AQS。利用CLH队列进行线程的管理，通过同步状态值来表示锁的状态和类型。</li>\n<li>\n<p>方法</p>\n<ol>\n<li><code class=\"language-text\">tryConvertToReadLock</code>/<code class=\"language-text\">tryConvertToOptimisticRead</code>/<code class=\"language-text\">tryConvertToWriteLock</code>。锁切换</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"六、abstractqueuedsynchronizer\"><a href=\"#%E5%85%AD%E3%80%81abstractqueuedsynchronizer\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>六、AbstractQueuedSynchronizer</h3>\n<ol>\n<li>在JDK1.6后增加了独占锁功能</li>\n<li>一个框架，用于实现依赖于FIFO等待队列的阻塞锁和相关的同步器（semaphores、events等），为依赖单个原子int值表示状态的同步器提供有用的基础</li>\n<li>状态字段的同步操作依赖<code class=\"language-text\">getState</code>、<code class=\"language-text\">setState</code>和<code class=\"language-text\">compareAndSetState</code>的原子操作来更新int值</li>\n<li>子类应定义为非公共内部帮助类来实现其封闭类的同步属性方法</li>\n<li>默认支持互斥模式或共享模式，等待线程共享FIFO队列</li>\n<li>ConditionObject类由支持独占模式的子类用作Condition实现</li>\n<li>\n<p>用法（使用<code class=\"language-text\">getState</code>、<code class=\"language-text\">setState</code>、<code class=\"language-text\">compareAndSetState</code>检查和修改同步状态），只支持实现以下方法【线程安全】</p>\n<ol>\n<li>tryAcquire。排他获取锁</li>\n<li>tryRelease。排他释放锁</li>\n<li>tryAcquireShared。共享获取锁</li>\n<li>tryReleaseShared。共享释放锁</li>\n<li>isHeldExclusively。是否为排他状态</li>\n</ol>\n</li>\n<li>\n<p><em>核心</em></p>\n<ol>\n<li>\n<p>CLH队列【JSR-166】。\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/09365aa4ff551b77347ee536ccfd91a6/37e0d/CLH.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 482px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 14.18918918918919%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsSAAALEgHS3X78AAAAV0lEQVQI101OiwoAIQjr/z83svJVt7LiBoob2zDNOccYqioib5dSiAiH2dJgcHe98A0EE8bNcs5UKRzMjIrYUDr3WypmhgO9tbUTDrxuON47f7q/ODTwARhvsM/sOPm6AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"image\"\n        title=\"\"\n        src=\"/static/09365aa4ff551b77347ee536ccfd91a6/37e0d/CLH.png\"\n        srcset=\"/static/09365aa4ff551b77347ee536ccfd91a6/12f09/CLH.png 148w,\n/static/09365aa4ff551b77347ee536ccfd91a6/e4a3f/CLH.png 295w,\n/static/09365aa4ff551b77347ee536ccfd91a6/37e0d/CLH.png 482w\"\n        sizes=\"(max-width: 482px) 100vw, 482px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<ol>\n<li>一个<strong>FIFO双向队列</strong>，队列中每个节点等待前驱节点释放共享状态（锁）被唤醒就可以了</li>\n<li>从tail入队【原子操作】，head出队【原子操作】</li>\n<li><code class=\"language-text\">prev</code>链用于处理取消</li>\n<li><code class=\"language-text\">next</code>链来实现阻止机制，每个节点的线程ID保留在主机的节点上，则前任通过遍历下一个链接来确定自己是哪个线程。</li>\n<li>在构造节点时，设置头和尾指针。</li>\n<li>\n<p>节点状态标识</p>\n<ol>\n<li>CANCELLED[1]。后驱节点被中断或超时，需要移出队列</li>\n<li>SIGNAL[-1]。后驱节点被阻塞了</li>\n<li>CONDITION[-2]。Condition专用</li>\n<li>PROPAGATE[-3]。传播，适用于共享模式</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>方法</li>\n<li><code class=\"language-text\">getState</code>。同步返回当前的值</li>\n<li><code class=\"language-text\">setState</code>。同步修改当前值</li>\n<li><code class=\"language-text\">compareAndSetHead</code>/<code class=\"language-text\">compareAndSetState</code>/<code class=\"language-text\">compareAndSetTail</code>/<code class=\"language-text\">compareAndSetWaitStatus</code>/<code class=\"language-text\">compareAndSetNext</code>。使用unsafe类来实现原子操作</li>\n<li><code class=\"language-text\">enq</code>。插入队列</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"七、abstractownablesynchronizer（16）\"><a href=\"#%E4%B8%83%E3%80%81abstractownablesynchronizer%EF%BC%8816%EF%BC%89\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>七、AbstractOwnableSynchronizer（1.6）</h3>\n<blockquote>\n<p>基础类，为AQS提供了独占锁等概念。包含定义拥有独占访问权限的锁</p>\n</blockquote>\n<h2 id=\"synchronized\"><a href=\"#synchronized\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>synchronized</h2>\n<ol>\n<li>提供对与每个对象相关联的隐式监视器锁的访问，但强制所有锁获取和释放以块结构的方式发生</li>\n<li>当获取多个锁时，它们必须以<strong>相反的顺序</strong>被释放，并且所有的锁都必须被释放在与它们相同的词汇范围内。</li>\n</ol>\n<h2 id=\"资料整理\"><a href=\"#%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>资料整理</h2>\n<ol>\n<li><a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">jdk8 内存模型</a></li>\n<li><a href=\"https://www.matools.com/api/java8\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">java se8 中文版</a></li>\n<li><a href=\"https://juejin.cn/post/6844904047305031693\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">史上最全的 Java 并发系列</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018948010\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JUC 同步队列</a></li>\n<li><a href=\"https://segmentfault.com/blog/ressmix_multithread?page=1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JUC 同步队列</a></li>\n</ol>","timeToRead":8,"frontmatter":{"title":"java concurrent locks","date":"March 06, 2020","spoiler":"并发"},"fields":{"slug":"/java-concurrent/"}}},"pageContext":{"slug":"/java-concurrent/","previous":null,"next":{"fields":{"slug":"/10.20 problem/","directoryName":"10.20 problem"},"frontmatter":{"title":"1020随笔"}}}},"staticQueryHashes":["336482444"]}