{"componentChunkName":"component---src-templates-blog-post-js","path":"/interview/","result":{"data":{"site":{"siteMetadata":{"title":"F&Y-BLOG","author":"kimifdw"}},"markdownRemark":{"id":"678ff474-50d1-55d1-ad28-887fa060c3c4","html":"<h2 id=\"linux\"><a href=\"#linux\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LINUX</h2>\n<ul>\n<li><strong>Q1</strong> 使用 Linux epoll 模型的 LT 水平触发模式，当 socket 可写时，会不停的触发 socket 可写的事件，如何处理？</li>\n<li><strong>A1</strong> 向 socket 写数据时直接调用 send()发送，当 send()返回错误码 EAGAIN，才将 socket 加入到 epoll，等待可写事件后再发送数据，全部数据发送完毕，再移出 epoll 模型，改进的做法相当于认为 socket 在大部分时候是可写的，不能写了再让 epoll 帮忙监控。上面两种做法是对 LT 模式下 write 事件频繁通知的修复，本质上 ET 模式就可以直接搞定，并不需要用户层程序的补丁操作。</li>\n</ul>\n<h2 id=\"netty\"><a href=\"#netty\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NETTY</h2>\n<ul>\n<li><strong>Q1</strong> Why do we really need multiple netty boss threads?</li>\n<li><strong>A1</strong> multiple boss threads are useful if we share NioEventLoopGroup between different server bootstraps\n<a href=\"https://stackoverflow.com/questions/34275138/why-do-we-really-need-multiple-netty-boss-threads\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">stackoverflow</a></li>\n</ul>\n<h2 id=\"java\"><a href=\"#java\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>java</h2>\n<ul>\n<li><strong>Q1</strong> Java nio 在 Linux 系统下的 epoll 空轮询问题, select 轮询事件返回数量为 0，NIO 照样不断的从 select 本应该阻塞的<code class=\"language-text\">Selector.select()/Selector.select(timeout)</code>中<code class=\"language-text\">wake up</code>出来，导致<strong>CPU 100%</strong>问题</li>\n<li><strong>A1</strong> 升级到高版本的 jdk 或者使用 netty 来实现\n<a href=\"https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6670302\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">java bug</a></li>\n</ul>","timeToRead":1,"frontmatter":{"title":"面试题收集","date":"October 29, 2020","spoiler":"linux"},"fields":{"slug":"/interview/"}}},"pageContext":{"slug":"/interview/","previous":{"fields":{"slug":"/epoll/","directoryName":"epoll"},"frontmatter":{"title":"epoll 介绍"}},"next":{"fields":{"slug":"/spring-boot/","directoryName":"spring-boot"},"frontmatter":{"title":"spring boot部分源码解读"}}}},"staticQueryHashes":["336482444"]}